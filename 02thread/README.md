# 线程管理

## 基本概念
* 线程就是程序的执行录像，即进程内部的控制序列，或者说是进程的子任务。
* 线程，轻量级，不拥有自己独立的内存资源，共享进程的代码区、数据区、堆区（没有栈区）、环境变量和命令行参数、文件描述符、信号处理函数、当前目录、用户ID和组ID等资源。
* 线程拥有自己独立的栈，因此也有独立的局部变量。
* 一个进程可以同时拥有多个线程，即同时被系统调度的多条执行路线，但至少要有一个主线程。

## 基本特点
* 线程是进程的一个实体，可作为系统独立调度和分派的基本单位。
* 线程有不同的状态，系统提供了多种线程控制原语，
* 线程不拥有自己的资源，只拥有从属于进程的全部资源，所有的资源分配都是面向进程的。
* 一个进程中可以有多个线程并发地运行。它们可以执行相同的代码，也可以执行不同的代码。
* 同一个进程的多个线程都在同一个地址空间内活动，因此相对于进程，现成的系统开销小，任务切换快。
* 线程间的数据交换不需要依赖类似于IPC的特殊通信机制，简单而高效。
* 每个线程拥有自己独立的线程ID、寄存器信息、函数栈、错误码和信号掩码。
* 线程之间存在优先级的差异。

## POSIX线程(pthread)
* 早期各厂商各自提供私有的线程库版本，接口和实现的差异非常大，不易于移植。
* IEEE POSIX 1003.1c(1995)标准，定义了统一的线程编程接口，遵循该标准的线程实现被统称为POSIX线程，即pthread。
* pthread包含一个头文件`pthread.h`和一个接口库`libpthread.so`。
  ```
    #include <pthread.h>
    ...
    gcc ... -lpthread
  ```
* 功能：
  * 线程管理：创建/销毁线程、分离/联合线程、设置/查询线程属性。
  * 线程同步
    * 互斥量：创建/销毁互斥量、加锁/解锁互斥量、设置/查询互斥量属性。
    * 条件变量：创建/销毁条件变量、等待/触发条件变量、设置/查询条件变量属性。

## 线程函数
### 创建线程
```c
#include <pthread.h>

int pthread_create(pthread_t *restrict thread,
                  const pthread_attr_t *restrict attr,
                  void *(*start_routine)(void *),
                  void *restrict arg);
```
* 参数
  * `thread`：线程ID，输出参数。`pthread_t`即`unsigned long int`。
  * `attr`：线程属性，NULL表示缺省属性。`pthread_attr_t`可能是整型也可能是结构，因实现而异。
  * `start_routine`：线程过程函数指针，参数和返回值的类型都是`void*`。启动线程本质上就是调用一个函数，只不过是在一个独立的线程内调用的。
  * `arg`：传递给线程过程函数的参数。线程过程函数的调用者是系统内核，而非用户代码，因此需要在创建线程时指定参数。若有多个参数，可通过传结构体指针。
* 返回值：成功返回0，失败返回错误码。
* 注意：
  * `restrict`：C99引入的编译优化指示符，提高重复解引用同一个指针的效率。解引用的目标值放到寄存器中，下次再解引用直接从寄存器取。
  * 在`pthread.h`头文件中声明的函数，通常以直接返回错误码的方式表示失败，而非以设置`errno`并返回-1。因为`errno`是全局变量。
  * `main`函数即主线程，`main`函数返回即主线程结束，主线程结束即进程结束，进程一旦结束其所有的线程即结束。
  * 应设法保证在线程过程函数执行期间，其参数所指向的目标持久有效。

### 等待线程结束
```c
#include <pthread.h>

int pthread_join(pthread_t thread, void **retval);
```
* 功能：等待thread参数所标识的线程结束。
* 返回值：成功返回0，失败返回错误码。
* 注意从线程过程函数中返回值的方法：
  * 线程过程函数将所需返回的内容放在一块内存中，返回该内存的地址，保证这块内存在函数返回，即线程结束以后依然有效。
  * 若`retval`参数为非`NULL`，则`pthread_join`函数将线程过程函数所返回的指针，拷贝到该参数所指向的内存中。
  * 若线程过程函数所返回的指针指向动态分配的内存，则还需保证在用过该内存之后释放之。

### 获取线程自身的ID
```c
#include <pthread.h>

pthread_t pthread_self(void);
```
* 返回值：成功返回0，不会失败，因为每个线程都有ID。

### 比较两个线程的ID
```c
#include <pthread.h>

int pthread_equal(pthread_t t1, pthread_t t2);
```
* 返回值：t1和t2相等返回非0，不等返回0。`pthread_t`有些实现是`unsigned long int`，有些是结构体，所以不能简单地用`==`判断。

### 终止线程
* 从线程过程函数中return。
* 调用`pthread_exit`函数。
```c
#include <pthread.h>

void pthread_exit(void *retval);
```
注意：在任何线程中调用`exit`函数都会终止整个进程。

### 线程执行轨迹
* 同步方式（非分离状态）
  * 创建线程之后，调用`pthread_join`函数等待其终止，并释放线程资源。
* 异步方式（分离状态）
  * 无需创建者等待，线程终止之后自行释放资源。
```
#include <pthread.h>

int pthread_detach(pthread_t thread);
```
* 功能：使`thread`参数所标识的线程进入分离（DETACH）状态。处于分离状态的线程终止后自动释放线程资源，且不能被`pthread_join`函数等待。
* 返回值：成功返回0，失败返回错误码。

### 取消线程
#### 向指定线程发出取消请求
```c
#include <pthread.h>

int pthread_cancel(pthread_t thread);
```
* 返回值：成功返回0，失败返回错误码。
* 注意：
  * 该函数只是向线程发出取消请求，并不等待线程终止。
  * 缺省情况下，线程收到取消请求后，并不会立即终止，而是仍继续运行，直到达到某个取消点。在取消点处，线程检查其自身是否已经被取消了，并做出相应动作。如果立即取消，可能导致数据不完整。

#### 设置调用线程的可取消状态
```c
#include <pthread.h>

int pthread_setcancelstate(int state, int *oldstate);
```
* 返回值：成功返回0，并通过`oldstate`参数输出原可取消状态（若非NULL），失败返回错误码。
* `state`取值：
  * `PTHREAD_CANCEL_ENABLE`：接受取消请求（缺省）。
  * `PTHREAD_CANCEL_DISABLE`：忽略取消请求。

#### 设置调用线程的可取消类型
```c
#include <pthread.h>

int pthread_setcanceltype(int type, int *oldtype);
```
* 返回值：成功返回0，并通过`oldtype`参数输出原可取消类型（若非NULL），失败返回错误码。
* `type`取值：
  * `PTHREAD_CANCEL_DEFERRED`：延迟取消（缺省）。被取消线程在接收到取消请求后并不立即响应，而是一直等到执行了特定的函数（取消点）之后再响应该请求。
  * `PTHREAD_CANCEL_ASYNCHRONOUS`：异步取消。被取消线程可以在任意时间取消，而不是得遇到取消点才能被取消。但是操作系统并不能保证这一点。


### 线程属性






