# CPP
C++代码的编译器是g++，但是也可以用gcc编译C++代码，要链接`stdc++`库。
```
g++ hello.cpp
gcc hello.cpp -lstdc++
```

## IO

| IO        | C        | C++    |
|-----------|----------|--------|
| stdin(0)  | scanf()  | cin对象  |
| stdout(1) | printf() | cout对象 |
| stderr(2) | perror() | cerr对象 |


## 名字空间
C++为了对全局变量、函数、宏、对象进行划分，避免名字冲突，将标准库的内容置于一个逻辑空间中，这个逻辑空间称为名字空间，即`std`。
* `using namespace std`
  * 使用名字空间`std`，即名字空间中的内容对当前作用于完全可见，当前作用中就可以直接使用名字空间中的所有函数、对象等。
* `use std`

## 枚举
* C++的枚举是强类型
* 枚举类型不能再用整数进行初始化或赋值
  * C中枚举是整数，可以用整数相互赋值和初始化
  * C++中整数不能赋值给枚举变量，但枚举值可以赋值给整数
* 枚举类型名可以省略`enum`关键字

## 联合
* C++支持匿名联合，允许C++中的变量以联合的方式存储布局

## 结构体
* 定义变量时，C++的`struct`关键字可以省略
* C++中，空结构体大小为`1`，C语言中空结构体大小为`0`
* C++中，结构体成员变量可以用static修饰，C语言中则不能
* C++中，结构体中可以定义函数，C语言中则不能
* C++中，结构体中支持继承，C语言中则不能

## 字符串
* C++中提供了字符串类型
* C语言中字符串：字面值字符串、字符数组，没有单独的字符串类型
* 字符串构造
  * 空构造
  * 字面值字符串构造
  * 构造函数构造
  * 用另外一个string构造
* 字符串操作
  * 可以用字符串直接赋值
  * 使用`+`操作符，拼接字符串
  * 支持`[]`操算符
  * 成员函数

## C++函数
* 支持重载、缺省值、哑元
* C++形参列表为空，表示void，在调用函数时不能穿任何参数
* C++不支持隐式声明，调用函数之前，必须先声明/定义
  * C语言支持隐式声明

### 函数重载
同一作用域中，函数名相同，参数列表不同。
* 在调用同名函数时，编译器会根据调用参数时传递的实参类型和个数来绑定调用的函数。在编译阶段就确定了调用的是哪个函数。
* 参数列表不同
  * 参数类型不同（同位置的形参类型）
  * 参数个数不同
  * 对于指针和引用类型的参数，常属性不同也构成重载
* 重载与函数返回值类型无关
* 调用重载函数
  * 调用重载函数，不是由程序员指定的，而是由编译器绑定的。
  * 编译器根据参数的个数和类型来绑定对应的函数，称为静态绑定。
  * 可能会引发歧义。
    * 在调用函数时，先根据函数名搜索函数。
    * 如果函数没有重载，如果类型不匹配，则编译器会对实参进行类型转换，如果能够转为参数的类型，则编译器直接绑定。如果不能转换，则编译器报错。
    * 如果调用的函数有重载，会根据参数的个数和类型进行匹配。如果有完全匹配的函数，则直接绑定。如果不能完全匹配，则对实参进行类型转换，转换后如果有合适的，也能进行绑定。
    * 如果没有完全匹配，类型转换后，有多个同等级的重载函数，则产生歧义。
      * 多个参数时，一个参数的类型转换高于多个参数的类型转换

### 重载原理
* g++编译器会对函数换名，汇编中的标示符与原函数名不同。
* gcc编译器不会对函数换名，汇编中的标示符与原函数名相同。

### extern "C"
* 告诉g++编译器，不要对函数进行更名操作
* C++开发的库给C语言用的时候，需要使用`extern "C"`

### 函数缺省值
* C++的形参可以有缺省值，调用时，可传参，也可不传
* 靠右原则：如果一个形参有缺省值，则其右边所有形参都必须由缺省值。
* 函数声明于定义分离时，缺省值只能出现在函数声明中。
* 注意缺省值和重载引发的歧义

### 哑元
* 形参只有类型名，没有形参名
  * C语言函数声明省略的形参名不算
* 只关心传递参数的类型，不关心值
* 意义在于构成重载，区分前++/--还是后++/--

### 内联函数
* C语言中内联函数为`static inline`
* C++中内联函数为`inline`
* 在调用内联函数时，并不是生成调用指令，而是直接使用内联函数的二进制指令替换调用指令，提高运行效率。
* 简单且使用频率高的函数定义为内联函数，才能突显内联的意义。

### 引用
* 引用即别名
* 定义引用形参，即用形参来引用实参，操作形参本质上就是操作实参
* 引用底层的本质是指针，把指针的解引用、取地址等复杂操作省略了
* 引用必须初始化
* 引用终身制
  * 引用了一个目标后，无法让这个引用再引用其他目标
  * 使用引用变量和目标变量是一样的，没有区别
* 对引用变量赋值，其实就是对目标变量赋值
* 应用不能为空
  * 没有空引用
* 引用一般用在形参列表
  * 不再使用指针传递参数，直接使用引用可以取代指针
  * 引用形参，可以修改实参的值
* 引用与指针的区别
  * 指针是实体变量，引用不是实体变量
    * sizeof(指针)==4/8
    * sizeof(引用)==目标大小
  * 指针可以为空，引用不能为空
  * 指针可以不初始化，引用必须初始化
  * 指针可以改变指向，引用不能修改引用目标
  * 可以定义指针的指针即二级指针，不可以定义引用的引用，没有二级引用
    * `int&&`是右值引用，不是二级应用
  * 可以定义指针的应用，不可以定义引用的指针
  * 可以定义数组的引用，不可以定义引用的数组
* const
  * C：变量只读，使用指针也能修改
  * C++：变量就是常量
    * const修饰的变量，使用常量进行初始化，编译时对所有使用该常量的地方直接使用常量值替换（编译期就能得到值）
    * const修饰的变量，使用变量进行初始化，运行时才能得到值。
  * C++中对象、指针、引用的常属性不能丢失，一旦丢失，编译报错。
  * C++中const修饰的变量必须初始化
* constexpr
  * C++11中引入，表示常量表达式
  * const修饰变量有两种情况
    * 初始值为常量表达式，编译阶段就被替换
      * 针对这种情况C++11引入了`constexpr`关键字来替换`const`
    * 初始值为非常量表达式
* 常对象与常对象引用
  * 常对象：常量
  * 用const修饰的对象，称为常对象
    * const修饰的是引用目标
  * 非常引用只能引用非常对象，常引用可以引用常对象和非常对象
* 左值引用与右值引用
  * 左值：可以置于`=`左边的值
  * 右值：不能置于`=`左边的值
  * 一般变量称为左值
  * 常量、字面值、表达式，称为右值
  * 左值引用`int& r= obj;`
    * 非常左值引用只能引用左值
    * 常左值引用可以引用右值
  * 右值应用`int&& r = obj;`
    * 只能引用右值
  * `const`和`constexpr`修饰的变量，依然是左值
* 引用的作用
  * 传参
    * 提高传参的效率、节省内存
  * 返回对象引用
    * 要保证函数返回后，所引用的对象依然有效

## 动态内存
* 可以使用C语言的`malloc/calloc/realloc/free`这套函数，但不建议
* C++申请动态内存使用`new`操作符
* C++申请数组动态内存空间使用`new[]`操作符
* 用`new`申请用`delete`释放，用`new[]`申请用`delete[]`释放，要对应起来
* C++中没有对应的`realloc`

### new/delete和malloc/free的区别
* `new/delete`是操作符，`malloc/free`是函数。
* `new`会调用类的构造函数，`delete`会调用类的析构函数，`malloc/free`则不会。
* `new`可以给申请的动态内存初始化，`malloc`则不能（`calloc`会清零）。
* `new`申请内存时只需指定类型，不需指定大小。`malloc`不需指定类型，而需指定大小。即`new`关心类型，`malloc`关心大小。
* `new`申请内存后，得到的指针类型为对应类型的指针，而`malloc`申请后得到的指针类型为`void*`，需要类型转换。
* `new`申请失败会抛出`bad_alloc`异常，`malloc`申请失败会返回`NULL`，并设置`errno`。






























