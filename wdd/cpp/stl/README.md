# STL(Standard Template Library)
标准模板库

## 模板
* C/C++是强类型语言
  * 类型是固定的
  * 定义变量时，要明确类型
  * 类型检查很严格
* 泛型编程
  * 将类型参数化
* 将类型参数化后，写出来的函数，称为函数模板。写出来的类，称为类模板。
* 函数模板和类模板可以实例化，得到具体的函数和类。
* 编写更加灵活通用的代码，提高代码复用，提高开发效率。

## 函数模板
* 函数模板定义
  ```c++
  template<typename T, ...>
  template<class T>
  template<typename T, typename U>
  ```
* `template`：是一个用于声明模板的标识符，‌而不是一个关键字。‌表明接下来的是一个函数模板或类模板。
* `typename`：是一个关键字，‌用于在模板编程中明确指出某个标识符是一个类型名，‌而不是一个变量或其他类型的标识符。‌可用`class`替换。
* `T`：泛型参数，代表某一类型。

### 函数模板实例化
在编译阶段，遇到函数模板时，用具体的类型将函数模板实例化成一个具体的函数。
* 显式指定类型
  * 隐式推导后有歧义
  * 无法隐式推导
    ```c++
    template<typename T>
    void fun() {
        T a;
    }
    ```
* 隐式推导类型：根据实参推导类型

### 函数模板二次编译
* 第一次编译：检查模板语法
* 第二次编译：模板实例化后，针对具体的类型再次编译

### 函数模板特殊化
针对某些类型，函数模板不再满足其要求，需要进行特殊处理。
* 重载函数模板：实现一个和函数模板同名的函数。会优先调用非模板函数。

### 函数模板非类型参数
* 允许函数模板类型参数可以有非类型参数
* 函数模板非类型参数必须显式实例化
* 函数模板非类型参数实例化必须用常量
  * `constexpr`：一定是常量
  * `const`：可能不是常量，取决于初始化

### 函数模板类型参数缺省值
* 遵循靠右原则
* 非类型参数也可以有缺省值


## 类模板
* 模板类型参数作用于成员变量
* 模板类型参数作用于成员函数
* 类模板必须显式实例化

### 类模板特化
* 全特化
  * 类模板中所有代码都重新写
* 成员特化
  * 只针对类模板中的个别函数特殊处理

* 局部特化
  * 针对特殊场景，进行特化处理
    * 通用版本是`T`类型，可以针对`T*`和`T[]`进行局部特化
    * 通用版本是`T`类型，可以针对`TKK`、`TTT`等情况进行局部特化
  * 在实例化时，会选择特化程度更高的类模板

### 类模板非类型参数和缺省模板类型
* 类模板非类型参数，在实例化时需要常量或常量表达式
* 模板缺省参数缺省类型遵循靠右原则

### 类模板分离编译
* 不支持`.h`和`.cpp`分离
  * 在实例化时需要用到类模板的代码，实例化出具体的类
    * 如果没有使用模板编，编译器在编译的时候无法确定模板的实例，所以编译器只能等到用户使用此模板的时候才能进行实例化，才能确定模板的具体类型，从而为其分配内存空间，生成符号。
  * 每个cpp文件单独编译
    * 如果单独编译模板的`.h`和`.cpp`文件，是不会生成对应函数符号
* 类模板和函数模板声明定义都是在`.h`中

### 类模板的应用
* 继承
* 派生

### 类模板作为模板类型参数
### 类模板作为成员
* 成员属性
* 成员函数
* 内部类型






