# 互斥锁
## 互斥锁的类型
* `PTHREAD_MUTEX_FAST_NP`：（缺省），标准互斥锁
  * 同一个线程第一上锁成功，第二次上锁会阻塞。
  * 此类型的互斥锁不会检测死锁。
  * 如果线程在不受限解除互斥锁的情况下尝试重新加锁，则会产生死锁。
  * 尝试解除由其他线程锁定的互斥锁，会产生不确定行为。
  * 如果尝试解锁未锁定的互斥锁，也会产生不确定行为。
  * 一个线程在某一时间段，只能对一个互斥锁加锁一次，且解锁与上锁应由同一线程来完成，加锁和解锁是一一对应的。
* `PTHREAD_MUTEX_RECURSIVE_NP`：递归互斥锁
  * 同一个线程第一加锁成功，第二次加锁也能成功，上锁次数（内部计数）。
  * 如果线程在不首先解除互斥锁的情况下尝试重新加锁，可以加锁成功。
  * 多次加锁需要相同次数解锁才能释放锁，其他线程才能加锁。
  * 如果线程尝试解除其他线程的锁（如别人上锁，我来解锁），会返回错误码。
  * 如果线程尝试对未锁定的锁解锁，会返回错误码。
* `PTHREAD_MUTEX_ERRORCHECK_NP`：检错互斥锁。
  * 同一个线程第一次加锁成功，第二次加锁会返回错误。
  * 此类互斥锁可提供错误检查。
  * 如果线程在不首先解锁的情况下尝试加锁，会返回错误。
  * 如果线程尝试解除其他线程的锁，会返回错误。
  * 如果线程尝试解除未锁定的锁，会返回错误。
* `PTHREAD_MUTEX_STALLED`：缺省
  * 如果一个线程退出之前没有对锁定的互斥锁解锁，则其他线程用`pthread_mutex_lock`加锁都会阻塞。
* `PTHREAD_MUTEX_ROBUST`：
  * 如果一个线程退出之前没有对锁定的互斥锁解锁，则其他线程用`pthread_mutex_lock`加锁会返回`EOWNERDEAD`。此时可调用`pthread_mutex_consistent`函数，
    让当前线程获得该互斥锁，然后通过`pthread_mutex_unlock`解锁。












